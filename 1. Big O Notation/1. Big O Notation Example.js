// 1에서 특정한 N 값과 사이에 있는 모든 숫자를 더하는 함수를 쓰고 싶다!

// 1
function addUpTo(n) {
    let total = 0;
    for (let i = 0; i <= n; i++) {
        total += i;
    }

    return total;
}

console.log(addUpTo(6));

console.log("--------------------------------------------------------");


// 2
function addUpTo2(n) {
    return n * (n + 1) / 2;
}

console.log(addUpTo2(6));

// 둘 다 답이 정확히 나온다
// 어떤 것이 나을까?
// 어떤 코드가 빠르고 어떤 코드가 메모리나 데이터에 대해 효율적이고 어떤 코드가 읽기 쉬울까?

// 가장 쉬운 것은 타이밍 펑션을 사용하는 것이다.

let t1 = performance.now();
addUpTo(1000000000);

let t2 = performance.now();
console.log(`Time Elapsed: ${(t2- t1) / 1000} seconds.`)

// 사용하면 1번 함수보다 2번 함수가 훨씬 짧은 시간 내에 처리하고 있는 것을 알 수 있다.
// 기기마다 사양이 다르고 기계에 무엇이 실행되고 있는지에 따라 다르다.
// 물론 그렇다고 1번 함수가 2번 함수보다 좋은 효율을 보여주지는 않을 것이다.
// 그럼에도 불구하고 완전히 효율에 대해 단정 지을 수는 없다는 것이다.

// 그러니 어떻게 시간을 측정하지 않고 알 수 있을까?
// 이럴 때 BIg O Notation을 사용하면 좋다!

// 비슷한 개념이지만 정확한 시간을 초로 표현하기 보다는 컴퓨터가 처리해야하는 연산 갯수로 세면 된다!
// 어떤 컴퓨터는 갯수는 변하지 않기 때문이다.

// 2번 함수는 1개의 곱하기, 1개의 더하기, 1개의 나누기로 있어서 연산을 총 3번 진행한다.
// 계산은 딱 3번 한다.

// 1번 함수는 연산 갯수는 루프안에 있으므로 n에 따라 연산의 갯수가 달라진다.
// n의 값이 클 수록 많은 연산을 실행한다.
// 5n + 2번의 연산을 실행하게 된다. 물론 중요한 것은 전체적인 큰 그림을 보는 것이다.
//